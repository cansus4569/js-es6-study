# 실행 컨텍스트
* 실행 컨텍스트는 자바스크립의 동작 원리를 담고 있는 핵심 개념
    * 스코프를 기반으로 식별자와 식별자에 바인딩된값을 관리하는 방식
    * 호이스팅이 발생하는 이유
    * 클로저의 동작 방식
    * 태스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식

## 소스코드의 타입
* ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.
* 4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.
    * 구분하는 이유 : 소스코드 타입에 따라 **실행 컨텍스트를 생성하는 과정과 관리 내용이 다름**

소스코드|설명
-|-
전역 코드|전역에 존재하는 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
함수 코드|함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
eval 코드|빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드를 말한다.
모듈 코드|모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.

## 소스코드의 평가와 실행
* 자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리
    * `소스코드의 평가` -> `소스코드의 실행`

* 소스코드의 평가
    * 실행 컨텍스트 생성
    * 변수, 함수등의 선언문만 먼저 실행하여 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록
* 소스코드의 실행
    * 선언문을 제외한 소스코드가 순차적으로 실행(런타임)
    * 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색
    * 소스코드의 실행 결과는 실행 컨텍스트가 관리하는 스코프에 등록

![source_code_process drawio](https://user-images.githubusercontent.com/63139527/174434077-8da15c19-6108-4290-9daa-3e056f644181.png)

```javascript
var x; // (1) 변수 선언
x = 1; // (2) 변수 값 할당

/*
(1) 과정은 소스코드의 평가
- 변수 선언문 "var x;" 실행
- 식별자 x는 실행 컨텍스트가 관리하는 스코프에 등록
- x는 undefined 로 초기화

(2) 과정은 소스코드의 실행
- 변수 할당문 "x = 1;" 실행
- 실행 컨텍스트가 관리하는 스코프에 x 변수가 등록되어 있는지 확인
- 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리
```

## 실행 컨텍스트의 역할
* 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경(렉시컬 환경)을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
* 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
* 식별자 & 스코프 : 실행 컨텍스트의 렉시컬 환경으로 관리
* 코드 실행 순서 : 실행 컨텍스트 스택으로 관리
```
전역 코드 평가(전역 변수, 전역 함수 선언문) -> 실행 컨텍스트 생성, 전역 스코프 등록
-> 전역 코드 실행(값 할당, 함수 호출) -> 함수 호출 발생
-> 전역 코드 실행 일시 중단 -> 함수 내부 진입
-> 함수 코드 평가(매개변수, 지역 변수 선언문) -> 실행 컨텍스트 생성, arguments 객체 생성, 지역 스코프 등록, this 바인딩 결정
-> 함수 코드 실행(값 할당, 메서드 호출) -> 함수 코드 실행 종료 & 복귀후 전역 코드 실행 재시작
-> 전역 코드 실행 -> 전역 코드 실행 종료
```
## 실행 컨텍스트 스택
* 실행 컨텍스트 스택은 **코드의 실행 순서를 관리**한다. (스택 자료구조 관리)
* 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트(=실행 중인 실행 컨텍스트)이다.

```javascript
// 실행 컨텍스트 스택 예제
const x = 1;
function foo() {
    const y = 2;
    function bar() {
        const z = 3;
        console.log(x+y+z); // 메서드 호출
    }
    bar(); // 함수 호출
}
foo() // 함수 호출
```

![exec_context_stack drawio](https://user-images.githubusercontent.com/63139527/174435619-05eb1faf-b530-47d7-b82d-10cae791bbce.png)

1. 전역 코드의 평가와 실행
2. foo 함수 코드의 평가와 실행
3. bar 함수 코드의 평가와 실행
4. foo 함수 코드로 복귀
5. 전역 코드로 복귀

## 렉시컬 환경
* 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조
* 실행 컨텍스트를 구성하는 컴포넌트
* 렉시컬 환경은 **스코프와 식별자를 관리**
    * 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 대한 바인딩된 값을 관리
    * 즉, 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할

![lexical_environment drawio](https://user-images.githubusercontent.com/63139527/174436265-eeefb5bd-fea6-466a-9d2a-233eff726123.png)

## 실행 컨텍스트의 생성과 식별자 검색 과정
* 예제를 통해 어떻게 실행 컨텍스트가 생성되고 코드 실행 결과가 관리되는지
* 그리고 어떻게 실행 컨텍스트를 통해 식별자를 검색하는지 살펴보자
```javascript
var x = 1;
const y = 2;

function foo (a) {
    var x = 3;
    const y = 4;

    function bar (b) {
        const z = 5;
        console.log(a + b + x + y + z);
    }
    bar(10);
}

foo(20);
```

### 1. 전역 객체 생성
* 전역 객체는 전역 코드가 **평가되기 이전**에 생성
    * 브라우저 : window 객체
* 전역 객체에는 `빌트인 전역 프로퍼티`, `빌트인 전역 함수`, `표준 빌트인 객체` 추가
* 클라이언트 사이드 기준 : Web API 포함
    * DOM, BOM, Canvas, XMLHttpRequest, fetch, SVG, Web Storage 등
* 전역 객체도 Object.prototype 상속받는다.
    * 즉, 전역 객체도 프로토타입 체인의 일원한다.
```javascript
// Object.prototype.toString
window.toString(); // [object Window]
window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // true
```

### 2. 전역 코드 평가
![global_code_eval drawio](https://user-images.githubusercontent.com/63139527/174446210-b20663d3-263b-4ff4-96fb-acfc5dc0f5c3.png)

**(1) 전역 실행 컨텍스트 생성**
- 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시

**(2) 전역 렉시컬 환경 생성**
- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩 한다.

**(2.1) 전역 환경 레코드 생성**

**(2.1.1) 객체 환경 레코드 생성**
- BindingObject는 전역 객체(=window)
- **var 키워드**로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
- var 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계" **동시 진행**
    - 변수 호이스팅 발생 원인

**(2.1.2) 선언적 환경 레코드 생성**
- **let, const 키워드**로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리
- const 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계" **분리되어 진행**

**(2.2) this 바인딩**
- 전역 환경 레코드의 **[ [ GlobalThisValue ] ] 내부슬롯**에 this가 바인딩된다.
    - 전역 코드에서 this는 전역 객체를 가리킴
- 전역 코드에서 this를 참조하면 [ [ GlobalThisValue ] ] 내부슬롯에 바인딩되어 있는 객체가 반환
- this 바인딩은 **전역 환경 레코드**와 **함수 환경 레코드**에만 존재

**(2.3) 외부 렉시컬 환경에 대한 참조 결정**
- 상위 스코프를 가리킨다.
- 단방향 링크드 리스트인 스코프 체인을 구현
- **전역 코드는 외부 렉시컬 환경에 대한 참조에 null 할당 (스코프 체인 종점)**

### 3. 전역 코드 실행
* 변수 할당문이 실행되어 전역 변수 x, y에 값이 할당
* foo 함수가 호출
* 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자 검색 시작
    * 실행 컨텍스트의 렉시컬 환경의 환경 레코드 참조
    * 그래도 없으면, 외부 렉시컬 환경의 환경 레코드 참조(스코프 체인)

![global_code_runtime drawio](https://user-images.githubusercontent.com/63139527/174446214-0ad8eab9-41af-4a4d-943a-af3f6b0cd205.png)


### 4. foo 함수 코드 평가
* foo 함수가 호출되면 전역 코드의 실행을 일시 중단
* foo 함수 내부로 코드의 제어권이 이동
* 함수 코드를 평가 시작

![foo_function_code_eval drawio](https://user-images.githubusercontent.com/63139527/174446204-21ab7249-7093-4eac-9c11-c50a0df96cab.png)

**(1) 함수 실행 컨텍스트 생성**
- foo 함수 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시

**(2) 함수 렉시컬 환경 생성**
- foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩 한다.

**(2.1) 함수 환경 레코드 생성**
- 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리

**(2.2) this 바인딩**
- 함수 환경 레코드의 [ [ ThisValue ] ] 내부 슬롯에 this가 바인딩된다.
- foo 함수는 일반 함수로 호출되었으므로 this는 전역 객체를 가리킨다.
- foo 함수 내부에서 this를 참조하면 [ [ ThisValue ] ] 내부 슬롯에 바인딩되어 있는 객체가 반환

**(2.3) 외부 렉시컬 환경에 대한 참조 결정**
- foo 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당
    - foo 함수는 전역 코드에 정의된 전역 함수
    - foo 함수 정의는 전역 코드 평가 시점에 평가됨
    - 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트
    - 전역 렉시컬 환경의 참조가 할당됨
- 자바스크립트는 **함수를 어디서 호출했는지가 아닌 어디에 정의했는지에 따라 상위 스코프를 결정**
- 함수의 상위 스코프를 함수 객체의 내부 슬롯 [ [ Environment ] ] 에 저장한다.
- 함수 객체의 내부 슬롯 [ [ Environment ] ]가 바로 렉시컬 스코프를 구현하는 메커니즘
    - 클로저를 이해할 수 있는 중요한 단서

### 5. foo 함수 코드 실행
* 매개변수에 인수가 할당
* 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당
* bar 함수가 호출
* 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색 시작
    * foo 함수 렉시컬 환경에서 식별자 x, y를 검색
    * 없으면, 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자 검색

![foo_function_code_runtime drawio](https://user-images.githubusercontent.com/63139527/174446207-421611ea-55a9-42bb-9cc8-1d7c4cc193e9.png)

### 6. bar 함수 코드 평가
* bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동
* bar 함수 코드를 평가하기 시작
* foo 함수 코드 평가와 동일함

![bar_function_code_eval drawio](https://user-images.githubusercontent.com/63139527/174446195-3c2ddfbc-2639-4c5f-98be-9f30ffa8e10c.png)

### 7. bar 함수 코드 실행
* 매개변수에 인수가 할당
* 변수 할당문이 실행되어 지역 변수 z에 값 할당
* `console.log(a + b + x + y + z);` 가 실행
    1. console 식별자 검색
        - 스코프 체인에서 검색
            - bar 함수 렉시컬 환경 -> foo 함수 렉시컬 환경 -> 전역 렉시컬 환경  
            -> 객체 환경 레코드의 BindingObject -> 전역 객체에서 발견!
    2. log 메서드 검색
        - console 객체에서 log 메서드 검색
            - console 객체의 프로토타입 체인을 통해 메서드 검색
    3. 표현식 a + b + x + y + z의 평가
        - console.log 메서드에 전달할 인수(표현식 a+b+x+y+z)를 평가하기 위해 a,b,x,y,z 식별자를 검색
        - 식별자는 스코프 체인에서 검색
            - a,x,y 식별자는 foo 함수 렉시컬 환경
            - b,z 식별자는 bar 함수 렉시컬 환경
    4. console.log 메서드 호출
        - 표현식 a+b+x+y+z 가 평가되어 생성된 값 42(20+10+3+4+5)를 console.log 메서드에 전달하여 호출

![bar_function_code_runtime drawio](https://user-images.githubusercontent.com/63139527/174446196-a3fd273b-67c2-4879-a30e-003a40cbe89b.png)

### 8. bar 함수 코드 실행 종료
* 실행할 코드가 없으므로 bar 함수 코드의 실행이 종료됨
* 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트 pop되어 제거

**참고**
```
실행 컨텍스트가 제거되면 렉시컬 환경까지 즉시 소멸하지 않음
렉시컬 환경은 독립적인 객체이다.
누군가에 의해 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸함
```

### 9. foo 함수 코드 실행 종료
* 실행할 코드가 없으므로 foo 함수 코드의 실행이 종료됨
* 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트 pop되어 제거

### 10. 전역 코드 실행 종료
* 실행할 전역 코드가 없으므로 전역 코드의 실행이 종료됨
* 실행 컨텍스트 스택에서 전역 실행 컨텍스트 pop되어 제거

## 실행 컨텍스트와 블록 레벨 스코프
```javascript
let x = 1;

if(true) {
    let x = 10;
    console.log(x); // 10
}
console.log(x); // 1
```

* if문 코드 블록이 실행되면 새로운 렉시컬 환경을 생성하여 기존의 렉시컬 환경을 교체
* if문 코드 블록의 실행이 종료되면 이전의 렉시컬 환경으로 되돌림 

![exec_context_block_level_scope drawio](https://user-images.githubusercontent.com/63139527/174446447-6577398e-3bf1-4f6d-b151-64f833a87d67.png)