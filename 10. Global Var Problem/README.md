# 전역 변수의 문제점
* 무분별한 전역 변수의 사용은 위험
* 지역 변수를 사용하는것을 권장
## 변수의 생명 주기

### 지역 변수의 생명 주기
* 지역 변수의 생명주기는 함수의 생명 주기와 일치 한다.
* 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있다.
    * 즉, 메모리 할당 -> 메모리 해제 -> 메모리 풀 반환

![local_var_life_cycle](https://user-images.githubusercontent.com/63139527/171998593-af35df2b-fd05-4c4a-a5aa-f9a3dcf79e77.png)
### 전역 변수의 생명 주기
* **var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.**

* var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
    * 브라우저 환경에서 전역 객체는 window
    * 전역 객체 window는 웹페이지를 닫기 전까지 유효하다.

`전역 객체`
```
코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 툭수한 객체
    - 클라이언트 사이드 환경(브라우저) : window 객체
    - 서버 사이드 환경(Node.js) : global 객체

전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array ...)와  
환경에 따른 호스트 객체(Web API, Node.js API), var 키워드로 선언한 전역 변수와  
전역 함수를 프로퍼티로 갖는다.
```

![global_var_life_cycle](https://user-images.githubusercontent.com/63139527/171998808-9eb565dc-bd85-48c7-b4f1-7456020f30c9.png)

## 전역 변수의 문제점
### 1. 암묵적 결합
* 전역 변수의 의도 : 코드 어디서든 참조하고 할당할 수 있는 변수 사용을 의미
* 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
    * 변수의 유효 범위가 크면 코드의 가독성이 나빠짐
    * 의도치 않게 상태가 변결될 수 있는 위험성 증가

### 2. 긴 생명 주기
* 메모리 리소스를 많이 잡아 먹게됨
* 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회가 많음
* var 키워드로 선언한 경우, 중복 가능성 -> 오류 발생 확률 높아짐

### 3. 스코프 체인 상에서 종점에 존재
* 전연 변수는 최상위 스코프 체인에 존재함
* 계층적 구조를 가지는 스코프 체인에서 **전역 변수의 검색 속도는 가장 느리다.**

### 4. 네임스페이스의 오염
* 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다.
* 다른 파일 내에서 동일한 이름의 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예쌍치 못한 결과를 가져올 수 있다.

## 전역 변수의 사용을 억제하는 방법
* 전역 변수의 무분별한 사용은 위험
* 전역 변수 사용 이유가 없다면 지역 변수를 사용
* 변수의 스코프는 좁을 수록 좋다.

### 1. 즉시 실행 함수
* 모든 코드를 즉시 실행 함수로 감사면 모든 변수는 즉실 실행 함수의 지역변수가 된다.
* 즉, 전역 변수 사용을 제한
* 라이브러리 등에서 자주 사용되는 방법
```javascript
(function () {
    var foo = 10; // 즉실 실행 함수의 지역 변수
    // ...
}());
console.log(foo); // error : foo is not defined
```
### 2. 네임스페이스 객체
* 전역에 네임스페이스 역할을 담당할 **객체**를 생성하고 전역 변수처럼 사용하고 싶은 변수를 **프로퍼티**로 추가하는 방법
* 네임스페이스 객체 안에 또 다른 네임스페이스 객체를 추가해서 **계층적으로 구성**할 수 있음
```javascript
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.person = {
    name: 'Lee',
    address: 'Seoul'
};
console.log(MYAPP.person.name); // Lee
```
* 식별자 충돌 방지 효과는 있으나, 객체 자체가 전역 변수에 할당되므로 유용하지 않음

### 3. 모듈 패턴
* 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방법
* 자바스크립트의 클로저를 기반으로 동작
* 효과 : 전역 변수 억제 + 캡슐화 구현 가능
    * 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 동작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
    * 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 함 (정보 은닉)

```javascript
var Counter = (function(){
    // private 변수
    var num = 0;

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
    // public 객체
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

### 4. ES6 모듈
* ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
* 모듈 내에서 var 키워드로 선언한 변수는 전역 변수가 아니며 window 객체의 프로퍼티도 아님
* script 태그에 type="module" 어트리뷰트를 추가해서 사용
* 모듈의 파일 확장자는 mjs를 권장
```javascript
<script type="module" src="lib.mjs"></script>
```
* ES6 모듈은 IEfmㄹ 포함한 구형 브라우저에서는 동작하지 않음
    * 그래서 트랜스파일링이나 번들링이 필요함
* 일반적으로 Webpack 등의 모듈 번들러는 사용함