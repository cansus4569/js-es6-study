# 함수 (function)
* 수학에서의 함수와 동일한 역할을 수행한다.
    * f( x, y ) = x + y
    * f( 2, 3 ) = 2 + 3 = 7

* 함수의 구성 요소
![function_structure](https://user-images.githubusercontent.com/63139527/171394125-af4a3f27-56f0-4ed0-b9dc-75af7eccecdf.png)

* 함수를 사용하는 이유
    * 코드의 재사용 (중복 제거)
    * 유지보수 편의성
    * 가독성

### 함수 리터럴
* 함수는 객체 타입의 값
    * 값이므로 변수에 할당 가능

* 변수에 함수 리터럴 할당
![function_literal](https://user-images.githubusercontent.com/63139527/171403113-e0ade0ba-c63b-4258-a075-7df2092296e5.png)
* 함수명 
    * 식별자이므로 네이밍 규칙을 따른다.
    * 함수 몸체 내에서만 참조할 수 있는 식별자
    * 함수 이름 생략 가능
        * 함수 이름이 있다면 "**기명 함수**"
        * 함수 이름이 생략이라면 "**무명 함수**"
* 매개변수
    * 소괄호로 감싸고 쉼표(,)로 구분한다.
    * 인수의 순서대로 --- 할당 ---> 매개변수 순서
    * 함수 몸체 내에서 변수와 동일하게 취급
* 함수 몸체
    * 함수 호출에 의해 실행된다.
    * 중괄호({ })로 안에(=코드 블록) 실행하기 위한 코드들이 정의됨
## 함수 정의 방법

### 1. 함수 선언문  ([예제](./src/function_definition.html))
* 함수 선언문은 함수명을 생략할 수 없다. (only 기명 함수)
* 함수 선언문은 표현식이 아닌 **문**으로 해석된다.
* 자바스크립트 엔진에서 함수 선언문으로 생성한 함수명을 이용하여 내부적으로 함수명과 동일한 식별자를 만들어서 함수 객체를 할당한다. 그래서 함수명으로 호출해서 사용이 가능하다.
* 즉, 함수는 함수명으로 호출하는 것이 아닌 **함수 객체를 가리키는 식별자로 호출**한다.
``` 
NOTE
    * 언뜻 보면 함수 선언문과 함수 표현식이 비슷해 보일 수 있다.
    * 함수 선언문과 함수 표현식의 한 끗 차이
        * 피연산자로 사용되면 -> 함수 표현식
        * 피연산자로 사용안되면 -> 함수 선언문
```
### 2. 함수 표현식 ([예제](./src/function_expression.html))
* 자바스크립트의 함수는 **일급 객체**이다.
    * 변수 할당 가능
    * 프로퍼티 값
    * 배열의 요소

* 함수 표현식 방법 : **함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방법**

* 함수 표현식의 경우 **익명 함수**로 사용 가능 (기명 함수로도 가능 [비추천])
```javascript
var add = function (x,y) { // 익명 함수 & 변수에 함수 객체 할당 (함수 표현식)
    return x + y;
};
console.log(add(1,2)) // 3
```
### 3. Function 생성자 함수
* 자바스크립트 빌트인 함수 Function 생성자 함수를 이용하여 만듬
* 생성자 함수로 만들어진 함수는 클로저가 동작하지 않음
```javascript
var add = new Function ('x', 'y', 'return x + y');
```
### 4. 화살표 함수 (ES6)
* ES6 부터 도입
* function 키워드 대신 화살표 '=>' 키워드를 사용해 함수를 정의함
* 익명 함수로만 정의
```javascript
const add = (x, y) => x + y;
console.log(add(2, 3)); // 5
```
## 함수 호이스팅 ([예제](./src/function_hoisting.html))
* [변수 호이스팅](../02.%20Variable/README.md)과 비슷한 맥락을 가지지만 약간의 차이는 있다.

* 자바스크립트 엔진은 코드들을 바로 실행(런타임 이전)하기 전에, 선언문들을 전체적으로 식별? 읽어들여 선언된 코드들을 인식 해둔다.
    * **함수 선언문**의 경우 : 함수 호이스팅 발생, 호출 가능
    * **함수 표현식**의 경우 : 변수 호이스팅 발생, 호출 불가능

* 선언문들은 런타임 이전에 읽어 드리지만, 값의 할당은 런타임때 실행된다.
    * 함수 선언문 : 선언 형태
    * 함수 표현식 : 할당 형태

* 변수 호이스팅 
    * 런타임 이전 : 식별자 생성, undefined 초기화
    * 런타임 이후 : 제대로된 할당 값 적용
* 함수 호이스팅
    * 함수 선언문
        * 런타임 이전 : 함수명과 동일한 식별자 생성, 함수 객체 초기화

    * 함수 표현식
        * 런타임 이전 : 식별자 생성, undefined 초기화 (변수 호이스팅 효과)
        * 런타임 이후 : 제대로된 할당 함수 객체 값 적용

## 함수 호출에 의한 매개변수 값의 전달 ([예제](./src/function_parameter.html))
* 데이터 타입(원시값, 객체)에 따른 값의 전달을 [여기에서](../07.%20Data%20Type%20Compare/README.md) 설명이되어 있다.
* 매개변수도 마찬가지로 변수이며, 타입에 따라 원시값/객체 가 될수 있다.
    * 원시값인 경우 원시 값 전달 (변경 불가능한 값)
    * 객체인 경우 참조 값 전달 (변경 가능한 값)
        * 동의어 : 함수가 외부 상태(객체 등...)를 변경
        * 객체 변화 추적이 어려움
* 객체 원본 훼손을 방지하기 위해
    * 불변 객체로 만들어 사용
    * 깊은 복사를 이용한 방법

* 외부 상태를 변경하지 않고 외부 상태에 의존하지 않는 함수 => **순수 함수**
* 순수 함수를 이용한 프로그래밍 패러다임 => **함수형 프로그래밍**

## 함수의 형태
### 1. 즉시 실행 함수 ([예제](./src/function_onetime_run.html))
* 한번만 호출되며 다시 호출 할 수 없다.
* 익명함수 만드는것이 일반적이다.
    * 기명함수로 만들어도 다시 호출 할 수 없다.
* 그룹 연산자 "( )" 를 반드시 사용해야 한다.
    * 이유 : 그룹 연산자 안에 함수 선언문이 함수 리터럴로 평가되기 위해서
    * 이유 : 그룹 연산자 "( )" 안에 내용들은 피연산자로 취급된다.
```javascript
// 1. 일반적인 방법 : 그룹연산자 내에 함수 호출 연산자 사용
(function () { 
    var a = 1;
    var b = 2;
    return a + b;
}());
// 2. 다른 방법 : 그룹 연산자 밖에 함수 호출 연산자 사용
(function () {
    var a = 1;
    var b = 2;
    return a + b;
})();

(                                               // 그룹 연산자 ( )
    function (a, b) {
        console.log(a + ' ' + b);
    } ('Hi' /* 인수1 */, 'Bye' /* 인수2 */)      // 함수 호출 ( )
);                                              // 그룹 연산자 ( )
```

### 2. 재귀 함수
* 재귀 호출(=함수가 자기 자신을 호출)을 수행하는 함수
```javascript
var factorial = function cal(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
};
console.log(factorial(5));
```

### 3. 중첩함수 or 내부함수
* 쉽게 말하면, 함수(외부함수)안에 함수(중첩함수 or 내부함수)가 있는 것을 말함
```javascript
function outer() {              // 외부 함수
    var x = 1;

    function inner() {          // 내부 함수
        var y = 2;
        console.log( x + y );   // x 값은 외부함수의 변수
    }
    inner();
}
outer();
```

### 4. 콜백함수
* 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
* 고차함수 : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수
* 콜백함수는 고차 함수에 의해 호출됨
* 고차 함수는 필요에 따라 콜백 함수에 인수를 전달 할 수 있다.
* 비동기 처리에 활용됨 (이벤트 처리, Ajax, 타이머 함수 등)
* **개인적인 결론 : 함수를 매개변수로 사용해서 쓰는거!**
```javascript
function repeat(n , func) { // 고차 함수 정의
    for(var i=0;i<n;i++) { // 반복문
        func(i); // func 호출 
    }
}

// 함수 표현식 (콜백 함수 정의)
var allPrint = function (i) {
    console.log(i);
};

// repeat : 고차 함수
// allPrint : 콜백 함수
repeat(5, allPrint); // 0 1 2 3 4 5

// 익명 함수 리터럴로 정의한 콜백 함수 사용 방법
repeat(5, function(i) {
    if(i%2) console.log(i);
}); // 1 2 3
```

### 5. 순수 함수 & 비순수 함수
* 순수 함수 : 외부 상태에 의존하지 않고 변경하지도 않는(부수효과X) 함수
* 비순수 함수 : 외부 상태에 의존하거나 변경하는(부수효과O) 함수

```javascript
var count = 0;
// 순수함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환
function increase(n) {
    return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태 변경
count = increase(count);
console.log(count); // 2
count = increase(count);
console.log(count); // 2
```
* 순수함수는 count 변수(외부 상태)를 직접적으로 변경시키는 것이 아니고  
입력받은 인수에게만 의존해 반환값을 만든다.

```javascript
var count = 0;  // increase() 함수에 의해 변경된다.
// 비순수 함수
function increase() {
    return ++count; // 함수가 직접적으로 외부 상태값을 변경함
}

increase();
console.log(count); // 1
increase();
console.log(count); // 2 
```
* 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 **객체**를 전달받으면 비순수 함수가 된다.

**NOTE**
```
순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고  
프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라고 한다.

매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를  
함수형 프로그래밍 패러다임에서 고차 함수라 한다.

콜백 함수는 함수형 프로그래밍 패러다임뿐만  
아니라 비동기 처리에 활용되는 중요한 패턴이다.

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해  
외부 상태를 변경하는 부수 효과를 최소화해서  
불변성을 지향하는 프로그래밍 패러다임이다.

<목표>
로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결  
변수 사용을 억제하거나 생명주기를 최소화 해서 상태 변경을 피해 오류를 최소화
```