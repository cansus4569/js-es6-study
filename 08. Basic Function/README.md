# 함수 (function)
* 수학에서의 함수와 동일한 역할을 수행한다.
    * f( x, y ) = x + y
    * f( 2, 3 ) = 2 + 3 = 7

* 함수의 구성 요소
![function_structure](https://user-images.githubusercontent.com/63139527/171394125-af4a3f27-56f0-4ed0-b9dc-75af7eccecdf.png)

* 함수를 사용하는 이유
    * 코드의 재사용 (중복 제거)
    * 유지보수 편의성
    * 가독성

### 함수 리터럴
* 함수는 객체 타입의 값
    * 값이므로 변수에 할당 가능

* 변수에 함수 리터럴 할당
![function_literal](https://user-images.githubusercontent.com/63139527/171403113-e0ade0ba-c63b-4258-a075-7df2092296e5.png)

* 함수명 
    * 식별자이므로 네이밍 규칙을 따른다.
    * 함수 몸체 내에서만 참조할 수 있는 식별자
    * 함수 이름 생략 가능
        * 함수 이름이 있다면 "**기명 함수**"
        * 함수 이름이 생략이라면 "**무명 함수**"

* 매개변수
    * 소괄호로 감싸고 쉼표(,)로 구분한다.
    * 인수의 순서대로 --- 할당 ---> 매개변수 순서
    * 함수 몸체 내에서 변수와 동일하게 취급

* 함수 몸체
    * 함수 호출에 의해 실행된다.
    * 중괄호({ })로 안에(=코드 블록) 실행하기 위한 코드들이 정의됨

## 함수 정의 방법

### 1. 함수 선언문  ([예제](./src/function_definition.html))
* 함수 선언문은 함수명을 생략할 수 없다. (only 기명 함수)
* 함수 선언문은 표현식이 아닌 **문**으로 해석된다.
* 자바스크립트 엔진에서 함수 선언문으로 생성한 함수명을 이용하여 내부적으로 함수명과 동일한 식별자를 만들어서 함수 객체를 할당한다. 그래서 함수명으로 호출해서 사용이 가능하다.
* 즉, 함수는 함수명으로 호출하는 것이 아닌 **함수 객체를 가리키는 식별자로 호출**한다.
``` 
NOTE
    * 언뜻 보면 함수 선언문과 함수 표현식이 비슷해 보일 수 있다.
    * 함수 선언문과 함수 표현식의 한 끗 차이
        * 피연산자로 사용되면 -> 함수 표현식
        * 피연산자로 사용안되면 -> 함수 선언문
```

### 2. 함수 표현식 ([예제](./src/function_expression.html))
* 자바스크립트의 함수는 **일급 객체**이다.
    * 변수 할당 가능
    * 프로퍼티 값
    * 배열의 요소

* 함수 표현식 방법 : **함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방법**

* 함수 표현식의 경우 **익명 함수**로 사용 가능 (기명 함수로도 가능 [비추천])
```javascript
var add = function (x,y) { // 익명 함수 & 변수에 함수 객체 할당 (함수 표현식)
    return x + y;
};
console.log(add(1,2)) // 3
```

### 3. Function 생성자 함수
* 자바스크립트 빌트인 함수 Function 생성자 함수를 이용하여 만듬
* 생성자 함수로 만들어진 함수는 클로저가 동작하지 않음
```javascript
var add = new Function ('x', 'y', 'return x + y');
```

### 4. 화살표 함수 (ES6)
* ES6 부터 도입
* function 키워드 대신 화살표 '=>' 키워드를 사용해 함수를 정의함
* 익명 함수로만 정의
```javascript
const add = (x, y) => x + y;
console.log(add(2, 3)); // 5
```


## 함수 호이스팅 ([예제](./src/function_hoisting.html))
* [변수 호이스팅](../02.%20Variable/README.md)과 비슷한 맥락을 가지지만 약간의 차이는 있다.

* 자바스크립트 엔진은 코드들을 바로 실행(런타임 이전)하기 전에, 선언문들을 전체적으로 식별? 읽어들여 선언된 코드들을 인식 해둔다.
    * **함수 선언문**의 경우 : 함수 호이스팅 발생, 호출 가능
    * **함수 표현식**의 경우 : 변수 호이스팅 발생, 호출 불가능

* 선언문들은 런타임 이전에 읽어 드리지만, 값의 할당은 런타임때 실행된다.
    * 함수 선언문 : 선언 형태
    * 함수 표현식 : 할당 형태

* 변수 호이스팅 
    * 런타임 이전 : 식별자 생성, undefined 초기화
    * 런타임 이후 : 제대로된 할당 값 적용
* 함수 호이스팅
    * 함수 선언문
        * 런타임 이전 : 함수명과 동일한 식별자 생성, 함수 객체 초기화

    * 함수 표현식
        * 런타임 이전 : 식별자 생성, undefined 초기화 (변수 호이스팅 효과)
        * 런타임 이후 : 제대로된 할당 함수 객체 값 적용