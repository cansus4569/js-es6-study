# 클로저
* 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(하스켈, 리스프, 얼랭, 스칼라 등)에서 사용되는 중요한 특성
* 자바스크립트 고유 특성은 아니라서 ECMAScript 사양에 정의되어 있지 않음

**MDN 정의**
```
클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.
```

* 중요한 키워드 : `함수가 선언된 렉시컬 환경` !

## 렉시컬 스코프 (정적 스코프)
* 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 `함수를 어디에 정의했는지`에 따라 `상위 스코프를 결정`한다.

* 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 상위 스코프에 대한 참조 값은 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정됨
    * 이러한 연결을 `스코프 체인` 이라 부름

## 함수 객체의 내부 슬롯 [ [ Environment ] ]
* (정의 및 선언을 통한 함수 객체 생성 시점) 
    * 함수는 자신의 내부 슬롯 [ [ Environment ] ]에 자신의 정의된 환경(현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조), 상위 스코프의 참조를 저장
* (함수 호출시(함수 평가) 시점)
    * 생성될 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장될 값이 [ [ Environment ] ] 내부 슬롯 참조 값이 할당됨

## 클로저와 렉시컬 환경
```javascript
const x = 1;
function outer() {
    const x = 10;
    const inner = function () {
        console.log(x);
    }
    return inner;
}
// outer 함수를 호출하면 중첩 함수 inner를 반환 
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop되어 제거
const innerFunc = outer();
innerFunc(); // 10
```
* 외부 함수(outer)보다 중첩 함수(inner)가 더 오래 유지되는 경우  
중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다.
    * 이러한 중첩 함수를 `클로저`라고 부른다.

* 보통 함수의 생명 주기가 다되면 실행 컨텍스트는 제거 되지만, 누군가에 의해 참조가 되고있다면, 렉시컬 환경은 소멸하지 않는다.
    * outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지는 소멸하지 않음
    * **outer 함수의 렉시컬 환경은 inner 함수의 [ [ Environment ] ] 내부슬롯에 참조되고 있기 때문** (가비지 컬렉션 대상이 되지 않음)

*  중첩 함수가 외부 함수보다 오래 유지되지만, 상위 스코프의 식별자를 참조 하지 않으면 클로저가 아니다.
    * 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다.(메모리 효율적 관리)
    ![no_closure_1](https://user-images.githubusercontent.com/63139527/174477194-f589c439-771d-4348-aaf8-7ba9251eb526.png)
    * [예제](./src/no_closure_1.html)

* 상위 스코프의 식별자를 참조하지만, 외부 함수 보다 중첩 함수의 생명주기가 짧으면, 클로저와 비슷한 행동이 실현됐지만 일반적으로 클로저라고 부르지 않는다.  
    ![no_closure_2](https://user-images.githubusercontent.com/63139527/174477202-d8457baf-2cc5-4b80-8080-b7ce1466ef4b.png)
    * [예제](./src/no_closure_2.html)

* 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.
    * 중첩 함수는 상위 스코프의 x, y 식별자 중에서 x만 참조함
        * 모던 자바스크립트 최적화를 통해 x 식별자만 기억하고 y 식별자는 메모리 해제된다.
    * 클로저에 의해 참조되는 상위 스코프의 변수를 `자유 변수` 라고 부른다.
    ![closure](https://user-images.githubusercontent.com/63139527/174477187-3133a593-33c7-46ac-8bca-16ce0d5d3e8e.png)
    * [예제](./src/closure.html)

## 클로저의 활용
* 클로저는 상태를 안정하게 변경하고 유지하기 위해 사용한다.
    * 상태를 안전하게 은닉
    * 특정 함수에게만 상태 변경을 허용
* [예제](./src/closure_example.html)

## 캡슐화와 정보 은닉
* 캡슐화란?
    * 객체의 상태를 나타내는 `프로퍼티`와 프로퍼티를 참조하고 조작할수 있는 동작인 `메서드`를 하나로 묶는 것을 말한다.
    * 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 `정보 은닉`이라 한다.

* 정보 은닉
    * 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 **정보를 보호**하고, 객체 간의 상호 의존성, 즉 **결합도를 낮추는 효과**를 가짐

* 자바스크립트에서는 다른 객체지향 프로그래밍 언어에서 가지는 접근제한자(public, private, protected)를 제공하지 않음
    * 즉, 객체의 모든 프로퍼티와 메서드는 기본적으로 public 하다.

* [예제](./src/information_hiding.html)
    * 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다.
        * 인스턴스 메서드를 사용한다면 자유 변수를 통해 private를 흉내 낼수 있음
        * 하지만, 프로토타입 메서드를 사용하면 불가능해짐
    * ES6의 Symbol 또는 WeakMap을 사용하여 private한 프로퍼티를 흉내낼 수 있음
        * 하지만, 근본적인 해결책은 안됨

* 클래스에 private 필드를 정의할 수 있는 새로운 표준 사양이 제안됨
    * 최신 브라우저(Chrome 74 이상) 및 최신 Node.js(버전 12이상) 에서 구현되어 있음

## 자주 발생하는 실수
* 함수 레벨 스코프 특성으로 인해 for문의 변수 선언문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상
* ES6의 let 키워드를 사용하면 깔끔하게 해결됨
    * for문 코드 블록의 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지함
    * **반목문 코드 블록 내부에서 함수를 정의**할 때 의미 있음 
```javascript
var func = [];

for(var i =0; i<3; i++) {
    func[i] = function() {
        return i;
    };
}

for(var j =0;j<func.length;j++) {
    console.log(func[j]());
}
// 출력 내용 : 3 3 3  
```

* 해결 방안 [예제](./src/fail_code_sucess.html) 코드 
    1. var 키워드로 해결 방안
    2. let 키워드로 해결 방안
    3. 함수형 프로그래밍 기법인 고차 함수를 사용하는 방안